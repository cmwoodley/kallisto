# optimisation/helpers.py

import _pickle as cpickle
import bz2
import json

import numpy as np

from rdkit import Chem
from rdkit.Chem import AllChem

from kallisto.atom import Atom
from kallisto.molecule import Molecule
from kallisto.units import Bohr

import config
import optuna
from optuna.samplers import TPESampler

def get_cm5_corrections_dict(at: list, coords: np.ndarray, CM5_ATOMIC_PARAMETERS: dict) -> np.ndarray:
    """A method to get CM5 corrections for hirshfeld charges with custom dict.

    Args:
    at - atomic numbers (list of integers)
    coords - atomic coordinates (np.ndarray)

    Returns:
    cm5_corrections - list of cm5 corrections (np.ndarray)
    """

    from kallisto.data import chemical_symbols
    from kallisto.data import ATOMIC_RCOV

    # Constant for bond order calculation in Angstrom
    alpha = -2.474 / 1.88973

    # Initialise per atom correction terms array
    at_corr = np.zeros((len(at), len(at)))

    # Iterate through atom pairs
    for i in range(len(at)):
        for j in range(i, len(at)):
            if i != j:
                i_sym = chemical_symbols[int(at[i])]
                j_sym = chemical_symbols[int(at[j])]

                # Calculate Pauling bond order
                dij = np.sqrt(np.sum((coords[i] - coords[j]) ** 2))
                Bkk = np.exp(alpha * (dij - ATOMIC_RCOV[i_sym] - ATOMIC_RCOV[j_sym]))

                # Retrieve CM5 atomic paramters from dict
                if (i_sym, j_sym) in CM5_ATOMIC_PARAMETERS.keys():
                    Dkk = CM5_ATOMIC_PARAMETERS[(i_sym, j_sym)]
                elif (j_sym, i_sym) in CM5_ATOMIC_PARAMETERS.keys():
                    # Negative to satisfy Dkk' = -Dk'k
                    Dkk = -CM5_ATOMIC_PARAMETERS[(j_sym, i_sym)]
                else:
                    Dkk = CM5_ATOMIC_PARAMETERS[i_sym] - CM5_ATOMIC_PARAMETERS[j_sym]
                    
                # Calculate atomic corrections
                # Atom pairs have negative correction to satisfy Dkk' = -Dk'k
                at_corr[i, j] = Bkk * Dkk
                at_corr[j, i] = -Bkk * Dkk

    # Return per atom sum
    return np.sum(at_corr, axis=1)

def kallisto_molecule_from_rdkit_molecule(rdkit_molecule: Chem.rdchem.Mol) -> Molecule:
    """Create a kallisto molecule from RDKit molecule.

    Args:
    rdkit_molecule: RDKit molecule

    Returns:
    A kallisto molecule (kallisto.molecule.Molecule)

    Raises:
    KallistoError: An error if the kallisto molecule cannot be created

    """
    # get the name of the molecule if it comes from SDF
    name = ""
    if rdkit_molecule.HasProp("_Name"):
        name = rdkit_molecule.GetProp("_Name")
    # get all xyz coordinates and split into list of lines
    xyz = Chem.rdmolfiles.MolToXYZBlock(rdkit_molecule).split("\n")
    # remove empty lines or molecule name from list
    xyz = [string for string in xyz if string != "" and string != name]
    # remove number of atoms as given in xmol files (first line)
    xyz = xyz[1:]

    # setup periodic table
    pt = Chem.GetPeriodicTable()
    # create list of atoms
    atoms = []
    # create kallisto molecule
    for coord in xyz:
        elem, x, y, z = coord.split()[:4]

        # convert atomic coordinates from Angstrom to Bohr
        position = [float(x) / Bohr, float(y) / Bohr, float(z) / Bohr]
        atom = Atom(symbol=pt.GetAtomicNumber(elem), position=position)
        atoms.append(atom)
    kallisto_mol = Molecule(symbols=atoms)
    if "numbers" not in kallisto_mol.arrays.keys():
        raise KeyError(
            "The kallisto molecule was not created for the input '{}'".format(
                Chem.MolToSmiles(rdkit_molecule)
            )
        )
    return kallisto_mol

def MolsFromSpartanFiles(file):
    '''
    Function to read in multi-molecule mol2 files generated by Spartan
    Molecules look weird when importing but connectivity fine.

    New coordinates generated using rdkit - would be the case using Jazzy from smiles so probably a better comparison anyway
    '''
    # with open(file,"r") as f:
    #         mol2 = f.readlines()

    mols = [x for x in Chem.SDMolSupplier(file,removeHs=False)]

    # starts = []
    # for i,line in enumerate(mol2):
    #     if line.find("#	File Created by: Spartan'20 Export") != -1:
    #         starts.append(i-1)
    # starts.append(len(mol2))

    # mols = []
    # for i in range(len(starts)-1):
    #     mol = Chem.MolFromMol2Block("".join(mol2[starts[i]:starts[i+1]]), removeHs=False)
    #     AllChem.Compute2DCoords(mol)
    #     AllChem.EmbedMolecule(mol)
    #     AllChem.MMFFOptimizeMolecule(mol)

    #     Chem.rdPartialCharges.ComputeGasteigerCharges(mol, nIter=50)
    #     mols.append(mol)
        
    return mols

def get_SMARTS_matches(smarts_patterns: list, mols: list) -> list:
    """Returns a list of SMARTs matches in a list of molecules

    Args:
    smarts_patterns: list(str)
    mols: list

    Returns:
    A list of indices (list)

    """

    smarts_patterns = [Chem.MolFromSmarts(x) for x in smarts_patterns]

    matches = []
    for i, mol in enumerate(mols):
        if any(mol.HasSubstructMatch(smarts) for smarts in smarts_patterns):
            matches.append(i)

    return matches

def run_optimisation(objective, study_filepath, verbose=False):
    """Abstraction for Optuna fitting.

    Includes early stopping logic and fixed seed for reproducibility.
    The fitting can be either verbose or not but always dumps a
    pickle file with the full logs of the process.

    """
    # early stopping logic (https://github.com/optuna/optuna/issues/1001)
    class EarlyStoppingExceeded(optuna.exceptions.OptunaError):
        early_stop = config.OPTUNA_EARLY_STOPPING
        early_stop_count = 0
        best_score = None

    def early_stopping_opt(study, trial):
        if EarlyStoppingExceeded.best_score is None:
            EarlyStoppingExceeded.best_score = study.best_value

        if study.best_value < EarlyStoppingExceeded.best_score:
            EarlyStoppingExceeded.best_score = study.best_value
            EarlyStoppingExceeded.early_stop_count = 0

        else:
            if (
                EarlyStoppingExceeded.early_stop_count
                > EarlyStoppingExceeded.early_stop
            ):
                EarlyStoppingExceeded.early_stop_count = 0
                raise EarlyStoppingExceeded()
            else:
                EarlyStoppingExceeded.early_stop_count = (
                    EarlyStoppingExceeded.early_stop_count + 1
                )
        return

    # run the optimisation with sampler for reproducibility
    if not verbose:
        optuna.logging.set_verbosity(optuna.logging.WARNING)
    sampler = TPESampler(seed=5)
    study = optuna.create_study(sampler=sampler)

    try:
        study.optimize(objective, timeout=None, callbacks=[early_stopping_opt])
    except EarlyStoppingExceeded:
        print(
            f"Early stopping exceeded: No new best scores \
            after {config.OPTUNA_EARLY_STOPPING} iterations"
        )
    print(f"The best parameters were {study.best_params}")

    # write the results out
    with bz2.BZ2File(study_filepath, "w") as f:
        cpickle.dump(study, f)

def dump_parameters_to_json(study_filepath, params_filepath):
    """Helper for dumping the study best parameters.

    Accepts the path to a study file, unpickles it,
    and dumps the best parameters into a serialisable.

    """
    # read the parameters
    with bz2.BZ2File(study_filepath, "rb") as f:
        study = cpickle.load(f)
    best_params = study.best_trial.params

    # dump the parameters
    with open(params_filepath, "w") as f:
        json.dump(best_params, f, indent=4)
